<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    xmlns="http://wadl.dev.java.net/2009/02"
    xmlns:wadl="http://wadl.dev.java.net/2009/02"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:c="http://www.w3.org/ns/xproc-step"
    xmlns:chk="http://www.rackspace.com/repose/wadl/checker"
    xmlns:sch="http://docs.rackspace.com/core/usage/schema"
    xmlns:rax="http://docs.rackspace.com/api"
    xmlns:cldfeeds="http://docs.rackspace.com/api/cloudfeeds"
    xmlns:event="http://docs.rackspace.com/core/event"
    xmlns:error="http://docs.rackspace.com/core/error"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dcxIpAddress="http://docs.rackspace.com/event/dcx/ip-address-association"
    xmlns:domain="http://docs.rackspace.com/event/domain"
    xmlns:maas="http://docs.rackspace.com/usage/maas"
    xmlns:cdnBand="http://docs.rackspace.com/usage/rackspacecdn/bandwidth"
    xmlns:cdnReqCount="http://docs.rackspace.com/usage/rackspacecdn/requestcount"
    xmlns:sitesSubscription="http://docs.rackspace.com/usage/sites/subscription"
    xmlns:xslout="http://www.rackspace.com/repose/wadl/checker/Transform"
    xmlns:saxon="http://saxon.sf.net/"
    xmlns:sum="http://docs.rackspace.com/core/usage/schema/summary"
    exclude-result-prefixes="sch c"
    version="2.0">

    <xsl:import href="productSchema-summary-util.xsl"/>
    <xsl:import href="../../target/xslt-artifacts/rm_private_attrs_for_obs.xsl"/>

    <!-- for samples -->
    <xsl:template match="comment()" mode="rm_priv"/>

    <xsl:namespace-alias stylesheet-prefix="xslout" result-prefix="xsl"/>
    <xsl:output method="xml" encoding="UTF-8" indent="yes"/>
    <xsl:output name="sample" method="xml" encoding="UTF-8" indent="yes" omit-xml-declaration="no" saxon:indent-spaces="2"/>
    <xsl:variable name="NS_PREFIX" select="'w_ns'"/>
    <!-- Event types, excepts for USAGE, which is a special case -->
    <xsl:variable name="EVENT_TYPES" as="xs:string*"
        select="('CREATE','USAGE_SNAPSHOT','USAGE_SUMMARY', 'UPDATE', 'DELETE', 'SUSPEND', 'UNSUSPEND', 'EXTENDED','UP','DOWN','INFO')"/>

    <xsl:template match="c:directory">
        <xsl:variable name="productSchemas" as="node()"    select="sch:addSchemaPos(sch:getSchemas(.))"/>
        <xsl:variable name="sampleMessages" as="node()"    select="sch:getMessages(.)"/>
        <xsl:comment>
            <xsl:text>&#x0a;    THIS WADL IS AUTOGENERATED DO NOT EDIT</xsl:text>
            <xsl:text>&#x0a;    GENERATED ON: </xsl:text><xsl:value-of select="current-dateTime()"/>
            <xsl:text>&#x0a;    PRODUCT SCHEMAS:</xsl:text>
            <xsl:for-each select="//c:directory[@name = 'sample_product_schemas' and not(ancestor::c:directory/@name = 'target')]/c:file[ends-with(lower-case(@name), '.xml')]/@name">
                <xsl:sort select="."/>
                <xsl:text>&#x0a;           </xsl:text><xsl:value-of select="."/>
            </xsl:for-each>
            <xsl:text>&#x0a;</xsl:text>
        </xsl:comment>
        <xsl:text>&#x0a;</xsl:text>
        <application>
            <xsl:for-each-group select="$productSchemas/sch:productSchema" group-by="@namespace">
                <xsl:namespace name="{sch:ns(current-group()[1]/@pos)}" select="current-group()[1]/@namespace"/>
            </xsl:for-each-group>
            <xsl:for-each-group select="$productSchemas//sch:productSchema" group-by="@serviceCode">
                <!-- Create resource group twice, once with and without usage summary. -->
                <xsl:for-each select="(false(), true())">
                    <xsl:variable name="summaryOnly" select="." as="xs:boolean"/>
                    <xsl:call-template name="sch:create-resource-type">
                        <xsl:with-param name="summaryOnly" select="$summaryOnly"/>
                        <xsl:with-param name="schemas" select="current-group()"/>
                        <xsl:with-param name="serviceCode" select="current-grouping-key()"/>
                        <xsl:with-param name="productSchemas" select="$productSchemas"/>
                        <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                    </xsl:call-template>
                </xsl:for-each>
            </xsl:for-each-group>
        </application>
    </xsl:template>
    <xsl:template name="sch:create-resource-type">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="serviceCode" as="xs:string"/>
        <xsl:param name="summaryOnly" as="xs:boolean"/>
        <xsl:param name="sampleMessages" as="node()"/>
        <xsl:param name="productSchemas" as="node()"/>
        <xsl:variable name="eventName">
            <xsl:choose>
                <xsl:when test="$summaryOnly">Usage Summary <xsl:value-of select="sch:lookupServiceCode($serviceCode)"/> Event</xsl:when>
                <xsl:otherwise><xsl:value-of select="sch:lookupServiceCode($serviceCode)"/> Event</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="id" as="xs:string">
            <xsl:choose>
                <xsl:when test="$summaryOnly">
                    <xsl:value-of select="concat($serviceCode,'Summary')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$serviceCode"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="currentSchemas" as="node()*">
            <xsl:choose>
                <xsl:when test="$summaryOnly">
                    <xsl:sequence select="$schemas[not(@type) or ('USAGE' = sch:stringList(@type)) or
                                          ('USAGE_SNAPSHOT' = sch:stringList(@type))]"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="$schemas"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:if test="not(empty($currentSchemas))">
            <resource_type id="{$id}Tenant">
                <xsl:variable name="opencurly">{</xsl:variable>
                <xsl:variable name="closecurly">}</xsl:variable>
                <resource path="{$opencurly}tid{$closecurly}/entries/{$opencurly}id{$closecurly}" id="getEntry_{$id}Tenant">
                    <param name="tid" type="xs:string" style="template"><doc>tenant ID</doc></param>
                    <param name="id" type="xs:anyURI" style="template">
                        <!-- Have to add wadl: prefix to doc to make test pass. Canonicalization seems to be messing up -->
                        <wadl:doc>urn:uuid:676f3860-447c-40a3-8f61-9791819cc82f</wadl:doc>
                    </param>
                    <method id="getEntry{$id}Tenant" name="GET">
                    <doc xml:lang="EN" title="Get {$eventName}" xmlns="http://docbook.org/ns/docbook">
                        <para role="shortdesc">This http request fetches one particular event whose ID is listed in the URI.</para>
                            <xsl:apply-templates select="$currentSchemas" mode="wadlDoc">
                                <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                                <xsl:with-param name="context">getEntry</xsl:with-param>
                                <xsl:with-param name="security">external</xsl:with-param>
                                <xsl:with-param name="summary" select="$summaryOnly"/>
                            </xsl:apply-templates>
                    </doc>
                        <xsl:if test="$id != 'CloudMonitoring' and $id != 'CloudServersOpenStack' and $id != 'CloudServers'">
                            <request>
                                <!-- Restrict representation to application/atom+xml. Means JSON not allowed -->
                                <param style="header" type="cldfeeds:AcceptHeaderType" rax:code="406" repeating="true" required="true"
                                       rax:message="getEntry{$id}: Accept header contains unsupported media types: application/*json"
                                       name="ACCEPT"/>
                            </request>
                        </xsl:if>
                        <response status="200">
                            <representation mediaType="application/atom+xml"/>
                        </response>
                        <!-- On Error -->
                        <response status="400">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Bad Request" xml:lang="EN">The request is missing one or more elements, or the values of some 
                                elements are invalid.</wadl:doc>
                        </response>
                        <response status="401">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Unauthorized" xml:lang="EN">Authentication failed, or the user does not have permissions for a requested operation.</wadl:doc>
                        </response>
                        <response status="409">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="The object already exists." xml:lang="EN">Duplicate entry ID sent 
                                in request. Fix entry and repost.
                            </wadl:doc>
                        </response>
                        <response status="500">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Internal Server Error" xml:lang="EN">The server encountered an unexpected condition which prevented it from fulfilling the request.</wadl:doc>
                        </response>
                        <response status="503">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Service Unavailable" xml:lang="EN">Service is not available. Try again later.</wadl:doc>
                        </response>
                    </method>
                </resource>
            </resource_type>

            <resource_type id="{$id}">
                <method id="add{$id}Entry" name="POST">
                    <xsl:attribute name="rax:roles" select="sch:getWriteRoles( $id, $schemas)"/>
                    <xsl:text>&#x0a;         </xsl:text>
                    <xsl:comment><xsl:text> GENERATED FILE! Do Not Hand Edit! </xsl:text></xsl:comment>
                    <xsl:text>&#x0a;         </xsl:text>
                    <wadl:doc title="Add {$eventName}" xmlns="http://docbook.org/ns/docbook">
                        <para role="shortdesc">Add <xsl:value-of select="sch:lookupServiceCode($serviceCode)"/>
                        <xsl:if test="$summaryOnly"> Summary </xsl:if> event.</para>
                            <xsl:apply-templates select="$currentSchemas" mode="wadlDoc">
                                <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                                <xsl:with-param name="context">addEntry</xsl:with-param>
                                <xsl:with-param name="security">internal</xsl:with-param>
                                <xsl:with-param name="summary" select="$summaryOnly"/>
                            </xsl:apply-templates>
                    </wadl:doc>
                    <request>
                        <representation mediaType="application/atom+xml" element="atom:entry">
                            <xsl:call-template name="sch:cross-check-params">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                                <xsl:with-param name="summaryOnly" select="$summaryOnly"/>
                            </xsl:call-template>

                            <!--
                               This deals with the edge case dealing with USAGE types.
                            -->
                            <xsl:choose>
                                <xsl:when test="$summaryOnly">
                                    <xsl:call-template name="sch:param">
                                        <xsl:with-param name="type" select="'USAGE_SUMMARY'"/>
                                        <xsl:with-param name="schemas" select="$currentSchemas"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:call-template name="sch:param">
                                        <xsl:with-param name="type" select="'USAGE'"/>
                                        <xsl:with-param name="schemas" select="$currentSchemas[not(@type) or ('USAGE' = sch:stringList(@type))]"/>
                                    </xsl:call-template>
                                </xsl:otherwise>
                            </xsl:choose>

                            <!--
                               @withEventType attributes, currently
                               don't work with USAGE_SUMMARY messages. -jw
                               TODO: FIX.
                            -->
                            <xsl:if test="not($summaryOnly)">
                                <xsl:call-template name="sch:event-type-checks">
                                    <xsl:with-param name="schemas" select="$currentSchemas"/>
                                </xsl:call-template>
                            </xsl:if>

                            <xsl:call-template name="sch:resource-type-checks">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                            </xsl:call-template>

                            <xsl:call-template name="sch:required-attribute-checks">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                            </xsl:call-template>

                            <xsl:call-template name="sch:forbid-event-error" />

                            <xsl:call-template name="sch:synth-attribute-check">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                            </xsl:call-template>

                            <!--
                                !!!!!!  HACK   !!!!!!
                                B-51154: restrict the use of GLOBAL DC/Region
                                This can be implemented inside the product schema XMLs once B-50883,
                                which depends on Repose 2.8.6 or above, is implemented.

                                JW:  We should probably implement this by extending the product schema
                                     to support of allowing global dcs etc, instead of doing this
                                     via individual product assurtions. That would be much cleaner.
                                     PLEASE FIX. :-)
                            -->
                            <xsl:call-template name="sch:restrict-global">
                                <xsl:with-param name="serviceCode" select="$serviceCode"/>
                                <xsl:with-param name="rules">
                                    <rax:restrict-rules>
                                        <!-- For these resource and resource types, the dc and region must be GLOBAL-->
                                        <!-- The nsprefix must be declared at the top of this XSL for this to work! -->
                                        <!-- nsprefixes and resourceTypes are both space delimited lists, whose lengths must match
                                             The tuple of (<serviceCode>, nsprefixe[n], resourceTypes[n]) describes a meessage which
                                             must have GLOBAL for dc & region.  All other nsprefixes & resourceTypes for the serviceCode
                                             cannot be GLOBAL.

                                             You'll also need to add the namespaces to the category checks & generations
                                             in atom_hopper_pre.xsl
                                        -->
                                        <rax:restrict-rule serviceCode="CloudMonitoring"    nsprefixes="maas"                       resourceTypes="CHECK"/>
                                        <rax:restrict-rule serviceCode="CloudSites"         nsprefixes="sitesSubscription"          resourceTypes="SITES_SUBSCRIPTION"/>
                                        <rax:restrict-rule serviceCode="DomainRegistration" nsprefixes="domain"                     resourceTypes="DOMAIN_SUBSCRIPTION"/>
                                        <rax:restrict-rule serviceCode="DcxIpAdmin"         nsprefixes="dcxIpAddress dcxIpAddress"  resourceTypes="IP_ADDRESS DEVICE"/>
                                        <rax:restrict-rule serviceCode="RackspaceCDN"       nsprefixes="cdnBand cdnReqCount"        resourceTypes="HOSTNAME HOSTNAME"/>
                                   </rax:restrict-rules>
                                </xsl:with-param>
                            </xsl:call-template>

                            <xsl:call-template name="sch:check-tenant-for-hybrid">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                            </xsl:call-template>

                            <!-- per WADL schema, all rax:preprocess/extensions have to be at the bottom of params -->
                            <xsl:call-template name="sch:xpath-assertions">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                                <xsl:with-param name="nscount" select="count(sch:getNSVersions($productSchemas//sch:productSchema))"/>
                            </xsl:call-template>

                            <!-- !!!!!! HACK !!!!!! -->

                            <!-- These synthasized XSLs should be associated via the product schema.  PLEASE FIX. :-) -->
                            <!-- Intententially use $id instead of $serviceCode, we don't want to perform the transform on a summary event -->

                            <!-- B-57395: implementation of BigData synthesized attribute -->
                            <xsl:if test="$id = 'BigData'">
                                <rax:preprocess href="bigdata.xsl"/>
                            </xsl:if>
                            <!-- B-59857: Cloud Load Balancer synthesized attributes -->
                            <xsl:if test="$id = 'CloudLoadBalancers'">
                                <rax:preprocess href="synthesize_lbaas.xsl"/>
                            </xsl:if>
                            <xsl:call-template name="sch:searchable">
                                <xsl:with-param name="schemas" select="$currentSchemas"/>
                                <xsl:with-param name="nscount" select="count(sch:getNSVersions($productSchemas//sch:productSchema))"/>
                            </xsl:call-template>
                            <rax:preprocess href="atom_hopper_pre.xsl"/>
                        </representation>
                    </request>
                    <!-- Okay -->
                    <response status="201" >
            			<wadl:doc title="Created">The request has been fulfilled. The entry has been created.</wadl:doc>
        			</response>
                    <!-- On Error -->
                    <response status="400">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Bad Request" xml:lang="EN">The request is missing one or more elements, or the values of some 
                                elements are invalid.</wadl:doc>
                        </response>
                        <response status="401">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Unauthorized" xml:lang="EN">Authentication failed, or the user does not have permissions for a requested operation.</wadl:doc>
                        </response>
                        <response status="409">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="The object already exists." xml:lang="EN">Duplicate entry ID sent 
                                in request. Fix entry and repost.
                            </wadl:doc>
                        </response>
                        <response status="500">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Internal Server Error" xml:lang="EN">The server encountered an unexpected condition which prevented it from fulfilling the request.</wadl:doc>
                        </response>
                        <response status="503">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Service Unavailable" xml:lang="EN">Service is not available. Try again later.</wadl:doc>
                    </response>
                </method>
                <xsl:variable name="opencurly">{</xsl:variable>
                <xsl:variable name="closecurly">}</xsl:variable>
                <resource path="entries/{$opencurly}id{$closecurly}" id="getEntry_{$id}">
                    <param name="id" type="xs:anyURI" style="template"> 
                        <!-- Have to add wadl: prefix to doc to make test pass. Canonicalization seems to be messing up --> 
                        <wadl:doc>urn:uuid:676f3860-447c-40a3-8f61-9791819cc82f</wadl:doc>
                    </param>
                    <method id="getEntry{$id}" name="GET">
                        <wadl:doc xml:lang="EN" title="Get {$eventName}" xmlns="http://docbook.org/ns/docbook">
                            <para role="shortdesc">This http request fetches one particular event whose ID is listed in the URI.</para>
                                <xsl:apply-templates select="$currentSchemas" mode="wadlDoc">
                                    <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                                    <xsl:with-param name="context">getEntry</xsl:with-param>
                                    <xsl:with-param name="security">internal</xsl:with-param>
                                    <xsl:with-param name="summary" select="$summaryOnly"/>
                                </xsl:apply-templates>
                        </wadl:doc>
                        <xsl:if test="$id != 'CloudMonitoring' and $id != 'CloudServersOpenStack' and $id != 'CloudServers'">
                        <request>
                            <!-- Restrict representation to application/atom+xml. Means JSON not allowed -->
                            <param style="header" type="cldfeeds:AcceptHeaderType" rax:code="406" repeating="true" required="true"
                                rax:message="getEntry{$id}: Accept header contains unsupported media types: application/*json"
                                name="ACCEPT"/>
                        </request>
                        </xsl:if>
                        <response status="200">
                            <representation mediaType="application/atom+xml"/>
                        </response>
                        <!-- On Error -->
                        <response status="400">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Bad Request" xml:lang="EN">The request is missing one or more elements, or the values of some 
                                elements are invalid.</wadl:doc>
                        </response>
                        <response status="401">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Unauthorized" xml:lang="EN">Authentication failed, or the user does not have permissions for a requested operation.</wadl:doc>
                        </response>
                        <response status="409">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="The object already exists." xml:lang="EN">Duplicate entry ID sent 
                                in request. Fix entry and repost.
                            </wadl:doc>
                        </response>
                        <response status="500">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Internal Server Error" xml:lang="EN">The server encountered an unexpected condition which prevented it from fulfilling the request.</wadl:doc>
                        	</response>
                        <response status="503">
                            <wadl:doc xmlns="http://docbook.org/ns/docbook" title="Service Unavailable" xml:lang="EN">Service is not available. Try again later.</wadl:doc>
                        </response>
                    </method>
                </resource>
           </resource_type>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sch:restrict-global">
        <xsl:param name="serviceCode" as="xs:string"/>
        <xsl:param name="rules" as="node()"/>
        <xsl:variable name="hitRules" select="$rules/rax:restrict-rules/rax:restrict-rule[@serviceCode = $serviceCode]"/>
        <xsl:choose>
            <xsl:when test="not(empty($hitRules))">
                <xsl:for-each select="$hitRules">
                    <xsl:variable name="rtypes" as="xs:string" select="./@resourceTypes"/>
                    <xsl:variable name="scode" as="xs:string" select="./@serviceCode"/>
                    <xsl:variable name="pfixes"  as="xs:string" select="./@nsprefixes"/>
                    <param name="checkDatacenter_{$scode}"
                           style="plain"
                           required="true"
                           path="if (
                                        (/atom:entry/atom:content/event:event/@type = ('USAGE','USAGE_SUMMARY','USAGE_SNAPSHOT')) and
                                        (
                                            (/atom:entry/atom:content/event:event) and
                                            not({sch:rtypesCheck(tokenize($pfixes, '\s+'), tokenize( ./@resourceTypes, '\s+' ))}) and
                                            (
                                                not(/atom:entry/atom:content/event:event/@dataCenter)
                                                or (/atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL')
                                            )
                                        )
                                    )
                                 then false()
                                 else true()"
                           rax:message="For this type of {$scode} event, @dataCenter must be present and can not be GLOBAL."/>
                    <param name="checkRegion_{$scode}"
                           style="plain"
                           required="true"
                           path="if (
                                        (/atom:entry/atom:content/event:event/@type = ('USAGE','USAGE_SUMMARY','USAGE_SNAPSHOT')) and
                                        (
                                            (/atom:entry/atom:content/event:event) and
                                            not({sch:rtypesCheck(tokenize($pfixes, '\s+'), tokenize( ./@resourceTypes, '\s+' ))}) and
                                            (
                                                not(/atom:entry/atom:content/event:event/@region)
                                                or (/atom:entry/atom:content/event:event/@region = 'GLOBAL')
                                            )
                                        )
                                    )
                                 then false()
                                 else true()"
                           rax:message="For this type of {$scode} event, @region must be present and can not be GLOBAL."/>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <param name="checkDatacenter"
                       style="plain"
                       required="true"
                       path="if (
                                    (/atom:entry/atom:content/event:event/@type = ('USAGE','USAGE_SUMMARY','USAGE_SNAPSHOT')) and
                                    (
                                        (/atom:entry/atom:content/event:event and not(/atom:entry/atom:content/event:event/@dataCenter))
                                        or (/atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL')
                                    )
                                )
                             then false()
                             else true()"
                       rax:message="For this product usage event, @dataCenter must be present and can not be GLOBAL."/>
                <param name="checkRegion"
                       style="plain"
                       required="true"
                       path="if (
                                    (/atom:entry/atom:content/event:event/@type = ('USAGE','USAGE_SUMMARY','USAGE_SNAPSHOT')) and
                                    (
                                        (/atom:entry/atom:content/event:event and not(/atom:entry/atom:content/event:event/@region))
                                        or (/atom:entry/atom:content/event:event/@region = 'GLOBAL')
                                    )
                                )
                             then false()
                             else true()"
                       rax:message="For this product usage event, @region must be present and can not be GLOBAL."/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="sch:check-tenant-for-hybrid">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each select="$schemas[@ranEnrichmentStrategy = 'HYBRID_TO_CORE_RAN']">
            <xsl:variable name="ns" as="xs:string" select="sch:ns(@pos)"/>
            <xsl:variable name="version" as="xs:string" select="@version"/>
             <param name="checkTenantIdForHybrid_{$ns}_{$version}"
                    style="plain"
                    required="true"
                    path="if ((/atom:entry/atom:content/event:event/{$ns}:product/@version='{$version}')
                          and not(starts-with(/atom:entry/atom:content/event:event/@tenantId, 'hybrid:')) ) then false() else true()"
                    rax:message="For {@serviceCode} product usage event, @tenantId must be begin with 'hybrid:'."/>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:synth-attribute-check">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each select="$schemas/sch:attribute[@use='synthesized']">
            <xsl:variable name="ns" as="xs:string" select="sch:ns(../@pos)"/>
            <xsl:variable name="version" as="xs:string" select="../@version"/>
            <xsl:variable name="attributeName" select="@name"/>
            <param name="checkSynthesized_{$attributeName}_{$version}"
                   style="plain"
                   required="true"
                   path="not(/atom:entry/atom:content/event:event[@type='USAGE']/{$ns}:product[@version='{$version}']/@{$attributeName})"
                   rax:message="The synthesized attribute '{$attributeName}' should not be included in the original event."/>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:xpath-assertions">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="nscount" as="xs:integer"/>
        <xsl:variable name="excludePrefixes" as="xs:string*"
                      select="('rax', 'util', 'xs', 'chk',
                               for $i in 1 to $nscount return concat($NS_PREFIX,xs:string($i)))"/>
        <xsl:if test="$schemas//sch:xpathAssertion[@scope='entry']">
            <rax:preprocess>
                <xslout:transform
                    xmlns:event="http://docs.rackspace.com/core/event"
                    xmlns:atom="http://www.w3.org/2005/Atom"
                    chk:mergable="true"
                    version="2.0">
                    <xsl:attribute name="exclude-result-prefixes">
                        <xsl:value-of select="$excludePrefixes" separator=" "/>
                    </xsl:attribute>
                    <xslout:import href="util.xsl"/>
                    <xslout:output method="xml" encoding="UTF-8"/>
                    <xslout:variable name="entry" select="/atom:entry"/>
                    <xslout:variable name="event" select="$entry/atom:content/event:event"/>
                    <xslout:template match="/">
                        <xslout:choose>
                            <xsl:for-each-group select="$schemas[sch:xpathAssertion[@scope = 'entry']]" group-by="@namespace">
                                <xslout:when test="$event/p:product">
                                    <xsl:namespace name="p" select="current-group()[1]/@namespace"/>
                                    <xslout:variable name="product" select="$event/p:product"/>
                                    <xslout:choose>
                                        <xsl:apply-templates select="current-group()" mode="xpath-assertions"/>
                                    </xslout:choose>
                                </xslout:when>
                            </xsl:for-each-group>
                        </xslout:choose>
                        <xslout:copy>
                            <xslout:apply-templates />
                        </xslout:copy>
                    </xslout:template>
                </xslout:transform>
            </rax:preprocess>
        </xsl:if>
    </xsl:template>
    <xsl:template match="sch:productSchema" mode="xpath-assertions">
        <xslout:when test="$product[@version = '{@version}']">
            <xsl:apply-templates mode="xpath-assertions"/>
        </xslout:when>
    </xsl:template>
    <xsl:template match="sch:xpathAssertion[@scope='entry']" mode="xpath-assertions">
        <xslout:choose>
            <xslout:when test="{@test}"/>
            <xslout:otherwise>
                <xslout:message terminate="yes"><xsl:value-of select="normalize-space(.)"/></xslout:message>
            </xslout:otherwise>
        </xslout:choose>
    </xsl:template>
    <xsl:template name="sch:required-attribute-checks">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each select="$schemas">
            <xsl:variable name="schema"  select="." as="node()"/>
            <xsl:if test="not(empty(sch:attribute[@withResource and @withEventType and @use='required']))">
                 <xsl:call-template name="sch:reqEventandResourceAtts">
                     <xsl:with-param name="schema" select="$schema"/>
                 </xsl:call-template>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:event-type-checks">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each select="$EVENT_TYPES">
            <xsl:variable name="type" select="."/>
            <xsl:variable name="selected_schemas" as="node()*" select="$schemas[$type = sch:stringList(@type)]"/>
            <xsl:call-template name="sch:param">
                <xsl:with-param name="type" select="."/>
                <xsl:with-param name="schemas" select="$selected_schemas"/>
            </xsl:call-template>
            <xsl:call-template name="sch:badEventType">
                <xsl:with-param name="type" select="."/>
                <xsl:with-param name="schemas" select="$selected_schemas"/>
            </xsl:call-template>
            <xsl:call-template name="sch:reqEventTypeAtts">
                <xsl:with-param name="type" select="."/>
                <xsl:with-param name="schemas" select="$selected_schemas"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:resource-type-checks">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each select="$schemas">
            <xsl:if test="sch:attribute/@withResource">
                <xsl:variable name="resource-types" select="sch:stringList(@resourceTypes)" as="xs:string*"/>
                <xsl:call-template name="sch:badResourceType">
                    <xsl:with-param name="schema" select="."/>
                    <xsl:with-param name="resource-types" select="$resource-types"/>
                </xsl:call-template>
                <xsl:call-template name="sch:reqResourceTypeAtts">
                    <xsl:with-param name="schema" select="."/>
                    <xsl:with-param name="resource-types" select="$resource-types"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:reqEventandResourceAtts">
        <xsl:param name="schema" as="node()"/>
        <xsl:variable name="resource-types" select="sch:stringList(@resourceTypes)" as="xs:string*"/>
        <xsl:for-each select="$resource-types">
            <xsl:variable name="rt" select="."/>
            <xsl:for-each select="$EVENT_TYPES">
                <xsl:variable name="et" select="."/>
                <xsl:variable name="requiredAttributes" as="xs:string*"
                              select="for $att in
                                      $schema/sch:attribute[$rt = sch:stringList(@withResource) and $et = sch:stringList(@withEventType) and @use='required']
                                      return $att/@name"/>
                <xsl:if test="not(empty($requiredAttributes))">
                    <param name="{concat(lower-case($rt),lower-case($et),$schema/@version)}ReqAttrCheck"
                           style="plain" required="true">
                        <xsl:attribute name="path">
                            <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectEventProductandResource($et, $rt, $schema/@pos, $schema/@version)"/>
                            <xsl:text> ) then </xsl:text>
                            <xsl:value-of select="concat(sch:selectEventProduct('', $schema/@pos,''),'[')"/>
                            <xsl:value-of select='for $attr in $requiredAttributes return concat("@",$attr)' separator=" and "/>
                            <xsl:text>] else true()</xsl:text>
                        </xsl:attribute>
                    <xsl:attribute name="rax:message">
                        <xsl:text>The following attributes (</xsl:text><xsl:value-of select="$requiredAttributes" separator=", "/>
                        <xsl:text>) are required in </xsl:text><xsl:value-of select="lower-case($et)"/>
                        <xsl:text> messages when the resource type is </xsl:text><xsl:value-of select="$rt"/>
                        <xsl:text>.</xsl:text>
                    </xsl:attribute>
                    </param>
                </xsl:if>
            </xsl:for-each>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:cross-check-params">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="summaryOnly" as="xs:boolean"/>
        <xsl:variable name="usedTypes" select="if ($summaryOnly) then 'USAGE_SUMMARY' else
                                               if ($schemas[not(@type)]) then
                                               distinct-values((sch:getTypes($schemas),'USAGE'))
                                               else sch:getTypes($schemas)"
                      as="xs:string*"/>
        <xsl:variable name="allTypes"  select="('USAGE', $EVENT_TYPES)" as="xs:string*"/>
        <xsl:variable name="notUsed" select="for $t in $allTypes return if ($t = $usedTypes) then () else sch:quoted($t)" as="xs:string*"/>
        <param name="cross_check" style="plain" required="true" rax:message="Events of this type not allowed in the feed.">
            <xsl:attribute name="path">
	      <xsl:text>not(/atom:entry/atom:content/event:event/@type = (</xsl:text>
              <xsl:value-of select="$notUsed" separator=","/>
              <xsl:text>))</xsl:text>
            </xsl:attribute>
        </param>
    </xsl:template>
    <xsl:template name="sch:forbid-event-error">
        <param name="forbid-event-error" 
               style="plain" 
               required="true"
               path="not(/atom:entry/atom:content/error:eventError)"
               rax:message="eventErrors are not allowed in this feed."/>        
    </xsl:template>
    <xsl:template name="sch:badResourceType">
        <xsl:param name="schema" as="node()"/>
        <xsl:param name="resource-types" as="xs:string*"/>
        <xsl:for-each select="$resource-types">
            <xsl:variable name="rtype" select="." as="xs:string"/>
            <xsl:variable name="badAttributeList" as="xs:string*"
                          select="for $att in $schema/sch:attribute[@withResource and not($rtype = sch:stringList(@withResource))] return $att/@name"/>
            <xsl:if test="not(empty($badAttributeList))">
                <param name="{concat(lower-case($rtype), $schema/@version)}BadResourceCheck" style="plain" required="true">
                    <xsl:attribute name="path">
                        <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectResource($rtype, $schema/@pos, $schema/@version)"/>
                        <xsl:text>) then </xsl:text>
                        <xsl:value-of select="concat(sch:selectEventProduct('', $schema/@pos, ''),'[not(')"/>
                        <xsl:value-of select="for $attr in $badAttributeList return concat('@',$attr)" separator=" or "/>
                        <xsl:text>)] else true()</xsl:text>
                    </xsl:attribute>
                    <xsl:attribute name="rax:message">
                        <xsl:text>The following attributes (</xsl:text><xsl:value-of select="$badAttributeList" separator=", "/>
                        <xsl:text>) are not allowed in messages of resource type </xsl:text><xsl:value-of select="lower-case($rtype)"/>
                        <xsl:text>.</xsl:text>
                    </xsl:attribute>
                </param>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:reqResourceTypeAtts">
        <xsl:param name="schema" as="node()"/>
        <xsl:param name="resource-types" as="xs:string*"/>
        <xsl:for-each select="$resource-types">
            <xsl:variable name="rtype" select="." as="xs:string"/>
            <xsl:variable name="reqAttributeList" as="xs:string*"
                          select="for $att in $schema/sch:attribute[@withResource and not(@withEventType) and
                                  @use='required' and $rtype = sch:stringList(@withResource)] return $att/@name"/>
            <xsl:if test="not(empty($reqAttributeList))">
                <param name="{concat(lower-case($rtype), $schema/@version)}ReqAttrCheck" style="plain" required="true">
                    <xsl:attribute name="path">
                        <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectResource($rtype, $schema/@pos, $schema/@version)"/>
                        <xsl:text>) then </xsl:text><xsl:value-of select="concat(sch:selectEventProduct('', $schema/@pos,''),'[')"/>
                        <xsl:value-of select='for $attr in $reqAttributeList return concat("@",$attr)' separator=" and "/>
                        <xsl:text>] else true()</xsl:text>
                    </xsl:attribute>
                    <xsl:attribute name="rax:message">
                        <xsl:text>The following attributes (</xsl:text><xsl:value-of select="$reqAttributeList" separator=", "/>
                        <xsl:text>) are required in messages of resource type </xsl:text><xsl:value-of select="lower-case($rtype)"/>
                        <xsl:text>.</xsl:text>
                    </xsl:attribute>
                </param>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:badEventType">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="type" as="xs:string"/>
        <xsl:for-each select="$schemas">
            <xsl:variable name="badAttributeList" as="xs:string*"
                          select="for $att in sch:attribute[@withEventType and not($type = sch:stringList(@withEventType))] return $att/@name"/>
            <xsl:if test="not(empty($badAttributeList))">
                <param name="{concat(lower-case($type), @version)}BadAttrCheck" style="plain" required="true">
                    <xsl:attribute name="path">
                        <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectEventProduct($type, @pos, @version)"/>
                        <xsl:text>) then </xsl:text><xsl:value-of select="concat(sch:selectEventProduct('', @pos,''),'[not(')"/>
                        <xsl:value-of select='for $attr in $badAttributeList return concat("@",$attr)' separator=" or "/>
                        <xsl:text>)] else true()</xsl:text>
                    </xsl:attribute>
                    <xsl:attribute name="rax:message">
                        <xsl:text>The following attributes (</xsl:text><xsl:value-of select="$badAttributeList" separator=", "/>
                        <xsl:text>) are not allowed in </xsl:text><xsl:value-of select="lower-case($type)"/>
                        <xsl:text> messages of this type.</xsl:text>
                    </xsl:attribute>
                </param>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:reqEventTypeAtts">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="type" as="xs:string"/>
        <xsl:for-each select="$schemas">
            <xsl:variable name="reqAttributeList" as="xs:string*"
                          select="for $att in sch:attribute[@withEventType and not(@withResource) and @use='required'
                                  and $type = sch:stringList(@withEventType)] return $att/@name"/>
            <xsl:if test="not(empty($reqAttributeList))">
                <param name="{concat(lower-case($type), @version)}ReqAttrCheck" style="plain" required="true">
                    <xsl:attribute name="path">
                        <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectEventProduct($type, @pos, @version)"/>
                        <xsl:text>) then </xsl:text><xsl:value-of select="concat(sch:selectEventProduct('', @pos,''),'[')"/>
                        <xsl:value-of select='for $attr in $reqAttributeList return concat("@",$attr)' separator=" and "/>
                        <xsl:text>] else true()</xsl:text>
                    </xsl:attribute>
                    <xsl:attribute name="rax:message">
                        <xsl:text>The following attributes (</xsl:text><xsl:value-of select="$reqAttributeList" separator=", "/>
                        <xsl:text>) are required in </xsl:text><xsl:value-of select="lower-case($type)"/>
                        <xsl:text> messages of this type.</xsl:text>
                    </xsl:attribute>
                </param>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="sch:param">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="type" as="xs:string"/>
        <xsl:if test="$schemas">
            <xsl:variable name="nsVersions" select="sch:getNSVersions($schemas)"/>
            <xsl:variable name="events" as="xs:string*">
                <xsl:for-each select="$nsVersions">
                    <xsl:variable name="vers">
                        <xsl:variable name="v" select="tokenize(@versions,',')"/>
                        <xsl:choose>
                            <xsl:when test="count($v) = 1">
                                <xsl:value-of select="$v[1]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('(',@versions,')')"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:value-of select="sch:selectProduct(@pos, $vers)"/>
                </xsl:for-each>
            </xsl:variable>
            <param name="{lower-case($type)}" style="plain" required="true">
                <xsl:attribute name="path">
                    <xsl:text>if (</xsl:text><xsl:value-of select="sch:selectEvent($type)"/>
                    <xsl:text>) then </xsl:text>
                    <xsl:value-of select="sch:selectEvent('')"/>
                    <xsl:text>[</xsl:text>
                    <xsl:value-of select='$events' separator=" or "/>
                    <xsl:text>] else true()</xsl:text>
                </xsl:attribute>
                <xsl:attribute name="rax:message">
                    <xsl:text>The version and namespace of the event you submitted does not correspond with events of type </xsl:text>
                    <xsl:value-of select="lower-case($type)"/>
                </xsl:attribute>
            </param>
        </xsl:if>
    </xsl:template>
    <xsl:function name="sch:rtypesCheck" as="xs:string">
        <xsl:param name="pfixes" as="xs:string*"/>
        <xsl:param name="rtypes" as="xs:string*"/>
        <xsl:variable name="checksList">
            <xsl:for-each select="$rtypes">
                <xsl:variable name="rtype" select="."/>
                <xsl:variable name="index" select="position()"/>
                <xsl:text>/atom:entry/atom:content/event:event/</xsl:text>
                <xsl:value-of select="$pfixes[$index]"/>
                <xsl:text>:product/@resourceType = '</xsl:text>
                <xsl:value-of select="$rtype"/>
                <xsl:text>' </xsl:text>
                <xsl:if test="position() &lt; count( $rtypes )">
                    <xsl:text>or </xsl:text>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="string-join( $checksList, '')"/>
    </xsl:function>
    <xsl:function name="sch:selectEvent" as="xs:string">
        <xsl:param name="type" as="xs:string"/>
        <xsl:variable name="ret">
            <xsl:text>/atom:entry/atom:content/event:event</xsl:text>
            <xsl:if test="$type">
                <xsl:text>[@type='</xsl:text>
                <xsl:value-of select="$type"/>
                <xsl:text>']</xsl:text>
            </xsl:if>
        </xsl:variable>
        <xsl:value-of select="xs:string($ret)" />
    </xsl:function>
    <xsl:function name="sch:selectProduct" as="xs:string">
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:param name="version" as="xs:string"/>
        <xsl:variable name="ret">
            <xsl:value-of select="concat(sch:ns($pos),':product')"/>
            <xsl:if test="$version">
                <xsl:value-of select="concat('[@version = ',$version,']')"/>
            </xsl:if>
        </xsl:variable>
        <xsl:value-of select="xs:string($ret)"/>
    </xsl:function>
    <xsl:function name="sch:selectEventProduct" as="xs:string">
        <xsl:param name="type" as="xs:string"/>
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:param name="version" as="xs:string"/>
        <xsl:variable name="ret">
            <xsl:value-of select="sch:selectEvent($type)"/>
            <xsl:value-of select="concat('/',sch:selectProduct($pos, $version))"/>
        </xsl:variable>
        <xsl:value-of select="xs:string($ret)"/>
    </xsl:function>
    <xsl:function name="sch:selectResource" as="xs:string">
        <xsl:param name="rtype" as="xs:string"/>
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:param name="version" as="xs:string"/>
        <xsl:variable name="ret">
            <xsl:value-of select="sch:selectEvent('')"/>
            <xsl:value-of select="concat('/',sch:selectProduct($pos, ''))"/>
            <xsl:text>[@resourceType = '</xsl:text><xsl:value-of select="$rtype"/>
            <xsl:text>' and @version='</xsl:text><xsl:value-of select="$version"/>
            <xsl:text>']</xsl:text>
        </xsl:variable>
        <xsl:value-of select="xs:string($ret)"/>
    </xsl:function>
    <xsl:function name="sch:selectEventProductandResource" as="xs:string">
        <xsl:param name="etype" as="xs:string"/>
        <xsl:param name="rtype" as="xs:string"/>
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:param name="version" as="xs:string"/>
        <xsl:variable name="ret">
            <xsl:value-of select="sch:selectEvent($etype)"/>
            <xsl:value-of select="concat('/',sch:selectProduct($pos, ''))"/>
            <xsl:text>[@resourceType = '</xsl:text><xsl:value-of select="$rtype"/>
            <xsl:text>' and @version='</xsl:text><xsl:value-of select="$version"/>
            <xsl:text>']</xsl:text>
        </xsl:variable>
        <xsl:value-of select="xs:string($ret)"/>
    </xsl:function>
    <xsl:function name="sch:getNSVersions" as="node()*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each-group select="$schemas" group-by="@namespace">
            <xsl:variable name="pos" as="xs:integer" select="current-group()[1]/@pos"/>
            <xsl:variable name="ns" as="xs:string" select="sch:ns($pos)"/>
            <xsl:variable name="versions" as="xs:string*" select="current-group()/@version"/>
            <sch:ns pfix="{$ns}" pos="{$pos}" namespace="{current-group()[1]/@namespace}">
                <xsl:attribute name="versions">
                    <xsl:value-of select="for $v in $versions return sch:quoted($v)" separator=","/>
                </xsl:attribute>
            </sch:ns>
        </xsl:for-each-group>
    </xsl:function>
    <xsl:function name="sch:stringList" as="xs:string*">
        <xsl:param name="in" as="node()?"/>
        <xsl:choose>
            <xsl:when test="not(empty($in))">
                <xsl:sequence select="tokenize(normalize-space(string($in)), ' ')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="()"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    <xsl:template name="sch:searchable">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="nscount" as="xs:integer"/>
        <xsl:variable name="excludePrefixes" as="xs:string*"
                      select="('event', 'rax', 'util', 'xs', 'chk',
                               for $i in 1 to $nscount return concat($NS_PREFIX,xs:string($i)))"/>
        <!--
            If we have at least one searchable attribute, then
            we need to add a preproc to handle it.
        -->
        <xsl:if test="$schemas//sch:attribute/@searchable">
            <rax:preprocess>
                <xslout:stylesheet
                    xmlns:event="http://docs.rackspace.com/core/event"
                    xmlns:atom="http://www.w3.org/2005/Atom"
                    version="1.0">
                    <xsl:attribute name="exclude-result-prefixes">
                        <xsl:value-of select="$excludePrefixes" separator=" "/>
                    </xsl:attribute>
                        <xslout:import href="util.xsl"/>
                        <xslout:output method="xml" encoding="UTF-8"/>
                        <xslout:template match="text()" mode="category"/>
                        <xslout:template match="node() | @*" mode="category">
                            <xslout:apply-templates select="@* | node()" mode="category"/>
                        </xslout:template>
                        <xsl:apply-templates select="$schemas" mode="addCategory"/>
                </xslout:stylesheet>
            </rax:preprocess>
        </xsl:if>
    </xsl:template>
    <xsl:template match="sch:productSchema[sch:attribute/@searchable | sch:attributeGroup/sch:attribute/@searchable]"
                  mode="addCategory">
        <xsl:variable name="namespace" as="xs:anyURI" select="@namespace"/>
        <xsl:variable name="version" as="xs:string" select="@version"/>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']">
            <xsl:namespace name="pf" select="$namespace"/>
            <atom:entry>
                <xslout:apply-templates select="@*"/>
                <atom:id><xslout:value-of select="atom:id"/></atom:id>
                <xslout:apply-templates mode="category" select="@* | node()"/>
                <xslout:apply-templates select="node()"/>
            </atom:entry>
        </xslout:template>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']/atom:id">
            <xsl:namespace name="pf" select="$namespace"/>
        </xslout:template>
        <xsl:if test="sch:attribute/@searchable">
            <xslout:template match="pf:product[@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:if>
        <xsl:for-each select="sch:attributeGroup[sch:attribute/@searchable]">
            <xslout:template match="pf:{@name}[../@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="sch:attribute[@searchable]" mode="addCategory">
        <xsl:variable name="inAttribute" as="xs:boolean"
                      select="name(..) = 'attributeGroup'"/>
        <xslout:call-template name="addCategory">
            <xslout:with-param name="term" select="@{@name}"/>
            <xslout:with-param name="prefix"
                               select="'{if ($inAttribute) then concat(../@name,'.',@name) else @name}:'"/>
            <xsl:if test="@default">
                <xslout:with-param name="default" select="'{@default}'"/>
            </xsl:if>
        </xslout:call-template>
    </xsl:template>
    <xsl:function name="sch:ns" as="xs:string">
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:value-of select="concat($NS_PREFIX,$pos)"/>
    </xsl:function>
    <xsl:function name="sch:quoted" as="xs:string">
        <xsl:param name="in" as="xs:string"/>
        <xsl:variable name="q" select="''''"/>
        <xsl:value-of select="concat($q,$in,$q)"/>
    </xsl:function>
    <xsl:function name="sch:getTypes" as="xs:string*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:copy-of select="distinct-values(for $s in $schemas return sch:stringList($s/@type))"/>
    </xsl:function>
    <xsl:function name="sch:getWriteRoles" as="xs:string*">
        <xsl:param name="serviceCode" as="xs:string" />
        <xsl:param name="schemas" as="node()*"/>
        <xsl:variable name="roles" select="distinct-values(for $s in $schemas return sch:stringList($s/@writeRole))"/>
        <xsl:if test="count($roles) > 1"><xsl:message terminate="yes">ERROR: The service code '<xsl:value-of select="$serviceCode"/>' has more than one role for writeRole: '<xsl:value-of select="$roles"/>'</xsl:message></xsl:if>
        <xsl:choose>
            <xsl:when test="$roles != ''">
                <xsl:value-of select="$roles"/>
            </xsl:when>
            <xsl:otherwise>cloudfeeds:service-admin</xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    <xsl:function name="sch:getSchemas" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each select="$dir//c:directory[@name = 'sample_product_schemas' and not(ancestor::c:directory/@name = 'target')]/c:file[ends-with(lower-case(@name), '.xml')]">
                <xsl:sort select="@name"/>
                <xsl:apply-templates select="document(resolve-uri(@name,base-uri(.)))//sch:productSchema" mode="copy"/>
            </xsl:for-each>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:getMessages" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:messages>
            <xsl:for-each select="$dir//c:directory[@name = 'message_samples' and not(ancestor::c:directory/@name = 'target')]//c:file[ends-with(lower-case(@name), 'response.xml')]">
                <xsl:sort select="@name"/>
                <sch:message
                        path="{resolve-uri(@name,base-uri(.))}"
                        json_path="{replace(resolve-uri(@name,base-uri(.)), 'xml', 'json')}"
                        namespace="{namespace-uri(document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product'])}"
                        version="{document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product']/@version}"
                        serviceCode="{document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product']/@serviceCode}"
                        type="{if(document(resolve-uri(@name,base-uri(.)))/atom:entry/atom:id) then 'getEntry' else
                           if(document(resolve-uri(@name,base-uri(.)))/atom:entry) then 'addEntry' else 'event'}"
                        summary="{contains(document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'event']/@type, 'SUMMARY')}"/>
            </xsl:for-each>
        </sch:messages>
    </xsl:function>
    <xsl:function name="sch:addSchemaPos" as="node()">
        <xsl:param name="schemas" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each-group select="$schemas//sch:productSchema" group-by="@namespace">
                <xsl:variable name="pos" select="position()"/>
                <xsl:for-each select="current-group()">
                    <sch:productSchema pos="{$pos}">
                        <xsl:apply-templates select="@* | node()" mode="copy"/>
                    </sch:productSchema>
                </xsl:for-each>
            </xsl:for-each-group>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:lookupServiceCode">
        <xsl:param name="ServiceCode" as="xs:string"/>
        <xsl:value-of select="
            if($ServiceCode = 'CloudBlockStorage')          then 'Cloud Block Storage' 
            else if($ServiceCode = 'CloudDNS')              then 'Cloud DNS'
            else if($ServiceCode = 'CloudFiles')            then 'Cloud Files'
            else if($ServiceCode = 'CloudSites')            then 'Cloud Sites'
            else if($ServiceCode = 'DomainRegistration')    then 'Domain Registration'
            else if($ServiceCode = 'CloudDatabase')         then 'Cloud Database'
            else if($ServiceCode = 'Glance')                then 'Glance'
            else if($ServiceCode = 'CloudLoadBalancers')    then 'Cloud Loadbalancers'
            else if($ServiceCode = 'CloudServers')          then 'Cloud Servers'
            else if($ServiceCode = 'RHEL')                  then 'RedHat Enterprise Linux'
            else if($ServiceCode = 'CloudMonitoring')       then 'Cloud Monitoring'
            else if($ServiceCode = 'CloudServersOpenStack') then 'Cloud Servers (OpenStack)'
            else if($ServiceCode = 'BigData')               then 'Big Data'
            else if($ServiceCode = 'CloudBackup')           then 'Cloud Backup'
            else if($ServiceCode = 'CloudQueues')           then 'Cloud Queueus'
            else if($ServiceCode = 'AtomHopper')            then 'Atom Hopper'
            else $ServiceCode"/>
    </xsl:function>
    <xsl:template match="node() | @*" mode="copy" priority="2">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="copy"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()" mode="#all"/>

    <xsl:template match="text()" mode="rm_priv" priority="1">
        <xsl:copy/>
    </xsl:template>

    <xsl:template match="sch:productSchema" mode="wadlDoc" xmlns="http://docbook.org/ns/docbook">
        <xsl:param name="sampleMessages"/>
        <xsl:param name="context"/>
        <xsl:param name="security"/>
        <xsl:param name="summary"/>
        <xsl:variable name="content">
            <xsl:choose>
                <xsl:when test="$security = 'external'">
                    <xsl:variable name="content_t1">

                        <xsl:variable name="sampleDoc"
                                      select="document( resolve-uri(
                                ($sampleMessages//sch:message[
                                @type = $context and
                                @namespace = current()/@namespace and
                                @version = current()/@version and
                                @serviceCode = current()/@serviceCode and
                                @summary = $summary]/@path)[1], base-uri()) )"/>

                        <xsl:variable name="sampleFiltered">
                            <xsl:call-template name="rmPrivAttrsTemplate">
                                <xsl:with-param name="atomDoc" select="$sampleDoc"/>
                            </xsl:call-template>
                        </xsl:variable>

                        <xsl:value-of select="saxon:serialize( $sampleFiltered, 'sample' )"/>

                    </xsl:variable>

                    <!-- get tenant Id -->
                    <xsl:variable name="tenantId">
                        <xsl:analyze-string select="$content_t1"
                                            regex="tenantId=&quot;([^&quot;]+)&quot;">
                            <xsl:matching-substring>
                                <xsl:value-of select="regex-group(1)"/>
                            </xsl:matching-substring>
                        </xsl:analyze-string>
                    </xsl:variable>

                    <!-- replace tenant Id -->
                    <xsl:value-of select="replace( $content_t1, 'events/entries', concat( concat( 'events/', $tenantId ), '/entries' ))"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of
                            select="replace( unparsed-text(resolve-uri(
                            ($sampleMessages//sch:message[
                            @type = $context and
                            @namespace = current()/@namespace and
                            @version = current()/@version and
                            @serviceCode = current()/@serviceCode and
                            @summary = $summary]/@path)[1], base-uri())), '&lt;!--.*--&gt;', '', 'sm' )"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="json_content">
            <xsl:value-of
                    select=" unparsed-text(resolve-uri(
                    ($sampleMessages//sch:message[
                    @type = $context and
                    @namespace = current()/@namespace and
                    @version = current()/@version and
                    @serviceCode = current()/@serviceCode and
                    @summary = $summary]/@json_path)[1], base-uri()))"/>
        </xsl:variable>
        <example>
            <title><xsl:value-of select="replace(normalize-space(./sch:description),'^(.+)\.$','$1')"/>, version <xsl:value-of select="@version"/></title>
            <xsl:if test="sch:attribute|sch:attributeGroup">
                <informaltable frame="all">                    
                    <xsl:processing-instruction name="dbhtml">table-width="100%"</xsl:processing-instruction>
                    <tgroup cols="4">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="5.39*"/>
                        <colspec colname="c3" colnum="3" colwidth="2*"/>
                        <colspec colname="c4" colnum="4" colwidth="1.5*"/>
                        <thead>                
                            <row>
                                <entry>Attribute Name</entry>
                                <entry>Description</entry>
                                <entry>Type</entry>
                                <entry>Optionality</entry>
                            </row>                
                        </thead>
                        <tbody>
                            <xsl:apply-templates select="sch:attribute" mode="wadlDoc">
                                <xsl:with-param name="security" select="$security"/>
                                <xsl:with-param name="summary" select="$summary"/>
                            </xsl:apply-templates>
                            <xsl:apply-templates select="sch:attributeGroup" mode="wadlDoc">
                                <xsl:with-param name="security" select="$security"/>
                                <xsl:with-param name="summary" select="$summary"/>
                            </xsl:apply-templates>
                        </tbody>
                    </tgroup>               
                </informaltable>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="$content != ''">
                    <para><emphasis role="bold">XML Sample</emphasis>
                        <programlisting language="xml"><xsl:copy-of select="replace($content,'\n.*atom.*feed.*ignore.*used for testing.*(\n)','$1')"/></programlisting>
                    </para>
                </xsl:when>
                <xsl:otherwise>
                    <programlisting language="xml" />
                </xsl:otherwise>
            </xsl:choose>

            <xsl:choose>
                <xsl:when test="$json_content != ''">
                    <para><emphasis role="bold">JSON Sample</emphasis>
                        <programlisting language="json"><xsl:copy-of select="$json_content"/></programlisting>
                    </para>
                </xsl:when>
                <xsl:otherwise>
                    <programlisting language="json" />
                </xsl:otherwise>
            </xsl:choose>

        </example>
    </xsl:template>

    <xsl:template match="sch:attribute" mode="wadlDoc"  xmlns="http://docbook.org/ns/docbook">
        <xsl:param name="security"/>
        <xsl:param name="summary"/>
        <xsl:if test="$security = 'internal' or not(@private and @private = 'true')">
          <row>
              <entry>
                  <para><code><xsl:value-of select="@name"/></code></para>
              </entry>
              <entry>
                  <para><xsl:value-of select="."/></para>
                  <xsl:if test="@allowedValues"><formalpara><title>Allowed Values:</title>
                      <para><xsl:for-each select="sch:stringList(@allowedValues)"><code><xsl:value-of select="."/></code><xsl:if test="not(position() = last())">, </xsl:if></xsl:for-each></para></formalpara></xsl:if>
              </entry>
              <entry>
                  <para><xsl:value-of select="sum:getTypeDoc( @type, $summary, @aggregateFunction)"/></para>
              </entry>
              <entry>
                  <para><xsl:value-of select="sum:getOptionalityDoc( @use, $summary, @aggregateFunction, @groupBy )"/></para>
              </entry>
          </row>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="sch:attributeGroup" mode="wadlDoc"  xmlns="http://docbook.org/ns/docbook">
        <xsl:param name="security"/>
        <xsl:param name="summary"/>
        <xsl:variable name="frequency">
            <xsl:choose>
                <xsl:when test="@minOccurs =  @maxOccurs">must occur exactly <xsl:value-of select="@minOccurs"/> times</xsl:when>
                <xsl:when test="@minOccurs = '0' and @maxOccurs = 'unbounded'">may occur zero or more times</xsl:when>
                <xsl:when test="@minOccurs = '0' and @maxOccurs != 'unbounded'">may occur zero to <xsl:value-of select="@maxOccurs"/> times</xsl:when>
                <xsl:when test="@minOccurs != '0' and @maxOccurs = 'unbounded'">may occur <xsl:value-of select="@minOccurs"/> or more times</xsl:when>
                <xsl:when test="@minOccurs != '0' and @maxOccurs != 'unbounded'">may occur <xsl:value-of select="@minOccurs"/> to <xsl:value-of select="@maxOccurs"/> times</xsl:when>
            </xsl:choose>
        </xsl:variable>
        <row>
            <entry namest="c1" nameend="c4">
                <para><emphasis role="bold">Attribute group </emphasis><code><xsl:value-of select="@name"/></code>: <xsl:value-of select="sch:description"/></para>
                <para>The <code><xsl:value-of select="@name"/></code> element <xsl:value-of select="$frequency"/> and 
                    takes the following attributes:</para>
            </entry>
        </row>
        <xsl:apply-templates select="sch:attribute" mode="wadlDoc">
            <xsl:with-param name="security" select="$security"/>
            <xsl:with-param name="summary" select="$summary"/>
        </xsl:apply-templates>
    </xsl:template>
    
</xsl:stylesheet>
